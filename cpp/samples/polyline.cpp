/*config.h is generated by fltk in your system
 * this file is used with fltk 1.3 with gl enabled.
 * compile by: fltk-config --use-gl --use-images --compile polyline.cpp
 * or something like: g++ -lX11 -lGL -lpng 'polyline.cpp' -o 'polyline'
*/
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "config.h" //config.h must always be placed before any Fl header
#include <FL/gl.h>
#include <FL/Fl_Box.H>
#include <FL/Fl_Tabs.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Value_Slider.H>
#include <FL/Fl_Radio_Light_Button.H>

namespace VASEr
{
	struct Vec2 { double x,y;};
	struct Color { float r,g,b,a;};
}
#define VASER_DEBUG
#include "../vaser/vaser.cpp"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#include "png_readwrite.cpp"

using namespace VASEr;
void test_draw();
#include "test1_base.cpp"

const int buf_size=20;
Vec2 AP[buf_size];
int size_of_AP=0;
Color AC[buf_size];
double AW[buf_size];

Fl_Window* main_wnd;
Gl_Window* gl_wnd;
Fl_Slider *weight, *feathering;
Fl_Button *poly, *bezi;
Fl_Button *feather, *no_feather_at_cap, *no_feather_at_core;
Fl_Button *jt_miter, *jt_bevel, *jt_round;
Fl_Button *jc_butt, *jc_round, *jc_square, *jc_rect;
Fl_Button *jc_both, *jc_first, *jc_last, *jc_none;
Fl_Button *colored, *alphaed, *weighted;
Fl_Button *skeleton, *triangulate;
Fl_Slider *bz_ap, *bz_ag, *bz_cu;

void line_update()
{
	Color cc[3];
	Color grey = {.4,.4,.4, 1};
	
	{ Color col={1 , 0, 0, 1}; cc[0]=col;}
	{ Color col={.8,.8, 0, 1}; cc[1]=col;}
	{ Color col={ 0, 0, 1, 1}; cc[2]=col;}
	
	for ( int i=0; i<size_of_AP; i++)
	{
		if ( colored->value())
			AC[i] = cc[i%3];
		else
			AC[i] = grey;
		
		if ( alphaed->value())
			AC[i].a = 0.5f;
		else
			AC[i].a = 1.0f;
			
		if ( weighted->value())
		{
			AW[i] = weight->value() * (0.05 + double(i*2)/size_of_AP);
		}
		else
		{
			AW[i] = weight->value();
		}
	}
}
void line_init( int N)
{
	switch (N)
	{
	case 2:
		AP[0].x=180; AP[0].y=270;
		AP[1].x=220; AP[1].y=30;
		size_of_AP = 2;
	break;
	
	case 3:
		AP[0].x=200; AP[0].y=100;
		AP[1].x=100; AP[1].y=200;
		AP[2].x=300; AP[2].y=200;
		size_of_AP = 3;
	break;
	
	case 4:
		AP[0].x=200; AP[0].y=50;
		AP[1].x=100; AP[1].y=150;
		AP[2].x=300; AP[2].y=150;
		AP[3].x=200; AP[3].y=250;
		size_of_AP = 4;
	break;
	
	case 5:
		AP[0].x=60; AP[0].y=250;
		AP[1].x=120; AP[1].y=50;
		AP[2].x=180; AP[2].y=250;
		AP[3].x=240; AP[3].y=50;
		AP[4].x=300; AP[4].y=250;
		size_of_AP = 5;
	break;
	
	case 6:
		AP[0].x=280; AP[0].y=110;
		AP[1].x=200; AP[1].y=50;
		AP[2].x=100; AP[2].y=150;
		AP[3].x=300; AP[3].y=150;
		AP[4].x=200; AP[4].y=250;
		AP[5].x=120; AP[5].y=190;
		size_of_AP = 6;
	break;

	case 7:
		AP[0].x=280; AP[0].y=110;
		AP[1].x=200; AP[1].y=50;
		AP[2].x=100; AP[2].y=50;
		AP[3].x=200; AP[3].y=150;
		AP[4].x=300; AP[4].y=250;
		AP[5].x=200; AP[5].y=250;
		AP[6].x=120; AP[6].y=190;
		size_of_AP = 7;
	break;
	}
	line_update();
	gl_wnd->set_drag_target( AP, size_of_AP); 
}
char get_joint_type()
{
	if ( jt_miter->value())
		return PLJ_miter;
	else if ( jt_bevel->value())
		return PLJ_bevel;
	else if ( jt_round->value())
		return PLJ_round;
	else
		return 0;
}
char get_cap_type()
{
	char cap;
	if ( jc_butt->value())
		cap=PLC_butt;
	else if ( jc_round->value())
		cap=PLC_round;
	else if ( jc_square->value())
		cap=PLC_square;
	else if ( jc_rect->value())
		cap=PLC_rect;

	if ( jc_both->value())
		cap+=PLC_both;
	else if ( jc_first->value())
		cap+=PLC_first;
	else if ( jc_last->value())
		cap+=PLC_last;
	else if ( jc_none->value())
		cap+=PLC_none;
	return cap;
}
void np_cb(Fl_Widget* W, void*)
{
	int n=3;
	sscanf( W->label(), "%d", &n);
	line_init(n);
	if( n<4)
	{
		poly->value(1);
		bezi->value(0);
	}
	line_update();
	gl_wnd->redraw();
}
void line_bezier(Fl_Widget* W, void*)
{
	gl_wnd->redraw();
}
void drag_cb(Fl_Widget* W, void*)
{
	line_update();
	gl_wnd->redraw();
}
void exportimg_cb(Fl_Widget* W, void*)
{
	Image img = renderer::get_image();
	if( img.buf)
	{
		save_png("capture.png",img.buf,img.width,img.height,4);
		free(img.buf);
	}
}

void make_form()
{
	Fl_Tabs* tabs = new Fl_Tabs(400,0,200,300);

	{ Fl_Group* tab = new Fl_Group(400, 20, 200, 300, "config");
		Fl_Box* o = new Fl_Box(FL_NO_BOX,400,25,200,20,"general configurations");
		//weight
		weight = new Fl_Value_Slider(400,50,200,20,"weight");
		weight->type(FL_HOR_SLIDER);
		weight->bounds(0.02,30.0);
		weight->callback(drag_cb);
		weight->value(8.0);
		
		{ Fl_Group* o = new Fl_Group(400,90,200,20);
			poly = new Fl_Radio_Light_Button(400,90,100,20,"polyline");
			bezi = new Fl_Radio_Light_Button(500,90,100,20,"polybezier");
			poly->callback(line_bezier);
			bezi->callback(line_bezier);
			poly->value(1);
			o->end();
		}

		//number of points
		(new Fl_Button(400,110,80,20,"2 points"))->callback(np_cb);
		(new Fl_Button(480,110,20,20,"3"))->callback(np_cb);
		(new Fl_Button(500,110,20,20,"4"))->callback(np_cb);
		(new Fl_Button(520,110,20,20,"5"))->callback(np_cb);
		(new Fl_Button(540,110,20,20,"7"))->callback(np_cb);

		//test options
		colored = new Fl_Light_Button(400,130,60,20,"colored");
		colored->callback(drag_cb);
		colored->value(1);
		alphaed = new Fl_Light_Button(460,130,70,20,"alpha-ed");
		alphaed->callback(drag_cb);
		alphaed->value(1);
		weighted = new Fl_Light_Button(530,130,70,20,"weighted");
		weighted->callback(drag_cb);
		skeleton = new Fl_Light_Button(400,150,80,20,"skeleton");
		skeleton->value(0);
		skeleton->callback(drag_cb);
		triangulate = new Fl_Light_Button(480,150,120,20,"triangulation");
		triangulate->value(0);
		triangulate->callback(drag_cb);
		//export button
		Fl_Button *exportimg;
		exportimg = new Fl_Button(400,170,200,20,"export image");
		exportimg->callback(exportimg_cb);
	tab->end();}

	{ Fl_Group* tab = new Fl_Group(400, 20, 200, 300, "polyline");
		Fl_Box* o = new Fl_Box(FL_NO_BOX,400,25,200,20,"polyline_opt");

		//feathering
		feather = new Fl_Light_Button(400,50,100,20,"feather");
		feather->value(1);
		feather->callback(drag_cb);
		feathering = new Fl_Value_Slider(400,70,200,20,"feathering");
		feathering->type(FL_HOR_SLIDER);
		feathering->bounds(1.0,10.0);
		feathering->callback(drag_cb);
		feathering->value(1.0);
		no_feather_at_cap  = new Fl_Light_Button(430,110,170,15,"no_feather_at_cap");
		no_feather_at_core = new Fl_Light_Button(430,125,170,15,"no_feather_at_core");
		no_feather_at_cap ->value(0);
		no_feather_at_core->value(0);
		no_feather_at_cap ->callback(drag_cb);
		no_feather_at_core->callback(drag_cb);

		//joint type
		{ Fl_Group* o = new Fl_Group(400,145,200,30);
			new Fl_Box(400,145,80,15,"joint type");
			jt_miter = new Fl_Radio_Light_Button(420,160,60,15,"miter");
			jt_bevel = new Fl_Radio_Light_Button(480,160,60,15,"bevel");
			jt_round = new Fl_Radio_Light_Button(540,160,60,15,"round");
			o->end();
			jt_miter->value(1);
			jt_miter->callback(drag_cb);
			jt_bevel->callback(drag_cb);
			jt_round->callback(drag_cb);
		}
		//cap type
		{ Fl_Group* o = new Fl_Group(400,180,200,45);
			new Fl_Box(400,180,80,15,"cap type");
			jc_butt   = new Fl_Radio_Light_Button(440,195,80,15,"butt");
			jc_round  = new Fl_Radio_Light_Button(520,195,80,15,"round");
			jc_square = new Fl_Radio_Light_Button(440,210,80,15,"square");
			jc_rect   = new Fl_Radio_Light_Button(520,210,80,15,"rect");
			o->end();
			jc_butt   ->value(1);
			jc_butt   ->callback(drag_cb);
			jc_round  ->callback(drag_cb);
			jc_square ->callback(drag_cb);
			jc_rect   ->callback(drag_cb);
		}
		{ Fl_Group* o = new Fl_Group(400,230,200,45);
			new Fl_Box(400,230,80,15,"cap parts");
			jc_both   = new Fl_Radio_Light_Button(440,245,80,15,"both");
			jc_first  = new Fl_Radio_Light_Button(520,245,80,15,"first");
			jc_last   = new Fl_Radio_Light_Button(440,260,80,15,"last");
			jc_none   = new Fl_Radio_Light_Button(520,260,80,15,"none");
			jc_both->value(1);
			jc_both ->callback(drag_cb);
			jc_first->callback(drag_cb);
			jc_last ->callback(drag_cb);
			jc_none ->callback(drag_cb);
		}
	tab->end();}

	/*{ Fl_Group* tab = new Fl_Group(400, 20, 200, 300, "BZ");
		Fl_Box* o = new Fl_Box(FL_NO_BOX,400,25,200,20,"polybezier_opt");
		bz_ap = new Fl_Value_Slider(400,70,200,15,"approximation_scale");
		bz_ag = new Fl_Value_Slider(400,105,200,15,"angle_tolerance");
		bz_cu = new Fl_Value_Slider(400,140,200,15,"cusp_limit");
		bz_ap->type(FL_HOR_SLIDER);
		bz_ag->type(FL_HOR_SLIDER);
		bz_cu->type(FL_HOR_SLIDER);
		bz_ap->bounds(0.1,5.0); bz_ap->value(BZ_default_approximation_scale); bz_ap->callback(drag_cb);
		bz_ag->bounds(0.01,0.52); bz_ag->value(BZ_default_angle_tolerance); bz_ag->callback(drag_cb);
		bz_cu->bounds(0.1,5.0); bz_cu->value(BZ_default_cusp_limit); bz_cu->callback(drag_cb);
	tab->end();}*/

	/*{ Fl_Group* tab = new Fl_Group(400, 20, 200, 300, "TS");
		Fl_Box* o = new Fl_Box(FL_NO_BOX,400,25,200,20,"tessellator");
	tab->end();}*/

	tabs->end();
}
void test_draw()
{	//main rendering

	renderer::before();

	polyline_opt opt={0};
	tessellator_opt tess={0};
	opt.feather    = feather->value();
	opt.feathering = feathering->value();
	opt.no_feather_at_cap = no_feather_at_cap->value();
	opt.no_feather_at_core = no_feather_at_core->value();
	opt.joint = get_joint_type();
	opt.cap   = get_cap_type();
	opt.tess = &tess;
	tess.triangulation = triangulate->value();

	Color cc={1,1,1,1};
	if ( bezi->value())
	{
		polybezier_opt bz_opt={0};
		bz_opt.poly = &opt;
		//bz_opt.approximation_scale = bz_ap->value();
		//bz_opt.angle_tolerance = bz_ag->value();
		//bz_opt.cusp_limit = bz_cu->value();
		gradient grad = {0};
		gradient_stop stop[10] = {0};
		grad.stops = stop;
		grad.length = 10;
		stop[0].t = 0.00; stop[0].type = GS_rgba; stop[0].color = AC[0];
		stop[1].t = 0.33; stop[1].type = GS_rgba; stop[1].color = AC[1];
		stop[2].t = 0.66; stop[2].type = GS_rgba; stop[2].color = AC[2];
		stop[3].t = 1.00; stop[3].type = GS_rgba; stop[3].color = AC[3];
		stop[4].t = 0.00; stop[4].type = GS_weight; stop[4].weight = AW[0];
		stop[5].t = 0.33; stop[5].type = GS_weight; stop[5].weight = AW[1];
		stop[6].t = 0.66; stop[6].type = GS_weight; stop[6].weight = AW[2];
		stop[7].t = 1.00; stop[7].type = GS_weight; stop[7].weight = AW[3];
		polybezier( AP, &grad, size_of_AP, &bz_opt);
		Color black={0,0,0,1};
		if ( skeleton->value())
		{
			polybezier( AP, cc, 1.0, size_of_AP, 0);
			polyline( AP, black, 1.0, size_of_AP, 0); //control lines
		}
	}
	else
	{
		polyline( AP, AC, AW, size_of_AP, &opt);
		if ( skeleton->value())
			polyline( AP, cc, 1.0, size_of_AP, 0);
	}

	renderer::after();
}

int main(int argc, char **argv)
{
	main_wnd = new Fl_Window( 600,300,"VASEr - polyline and bezier example");
		make_form(); //initialize
		gl_wnd = new Gl_Window( 0,0,400,300);  gl_wnd->end(); //create gl window
		line_init(4);
	main_wnd->end();
	main_wnd->show();
	main_wnd->redraw();
	
	return Fl::run();
}
